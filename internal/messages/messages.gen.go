// Package messages provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.15.1-0.20231015101446-d663b6c2722f DO NOT EDIT.
package messages

import (
	"encoding/json"
	"errors"
	"fmt"

	"github.com/oapi-codegen/runtime"
)

// ChallengeRequestMessage defines model for ChallengeRequestMessage.
type ChallengeRequestMessage struct {
	// Challenge String based on which the challenge must be solved.
	Challenge string `json:"challenge"`
}

// ChallengeResponseMessage defines model for ChallengeResponseMessage.
type ChallengeResponseMessage struct {
	// Solution The solution found in response to a server challenge request.
	Solution string `json:"solution"`
}

// Message defines model for Message.
type Message struct {
	MessageType string `json:"messageType"`
	union       json.RawMessage
}

// WordOfWisdomRequestMessage defines model for WordOfWisdomRequestMessage.
type WordOfWisdomRequestMessage = map[string]interface{}

// WordOfWisdomResponseMessage defines model for WordOfWisdomResponseMessage.
type WordOfWisdomResponseMessage struct {
	Quote string `json:"quote"`
}

// AsChallengeRequestMessage returns the union data inside the Message as a ChallengeRequestMessage
func (t Message) AsChallengeRequestMessage() (ChallengeRequestMessage, error) {
	var body ChallengeRequestMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChallengeRequestMessage overwrites any union data inside the Message as the provided ChallengeRequestMessage
func (t *Message) FromChallengeRequestMessage(v ChallengeRequestMessage) error {
	t.MessageType = "ChallengeRequestMessage"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChallengeRequestMessage performs a merge with any union data inside the Message, using the provided ChallengeRequestMessage
func (t *Message) MergeChallengeRequestMessage(v ChallengeRequestMessage) error {
	t.MessageType = "ChallengeRequestMessage"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsChallengeResponseMessage returns the union data inside the Message as a ChallengeResponseMessage
func (t Message) AsChallengeResponseMessage() (ChallengeResponseMessage, error) {
	var body ChallengeResponseMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromChallengeResponseMessage overwrites any union data inside the Message as the provided ChallengeResponseMessage
func (t *Message) FromChallengeResponseMessage(v ChallengeResponseMessage) error {
	t.MessageType = "ChallengeResponseMessage"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeChallengeResponseMessage performs a merge with any union data inside the Message, using the provided ChallengeResponseMessage
func (t *Message) MergeChallengeResponseMessage(v ChallengeResponseMessage) error {
	t.MessageType = "ChallengeResponseMessage"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsWordOfWisdomRequestMessage returns the union data inside the Message as a WordOfWisdomRequestMessage
func (t Message) AsWordOfWisdomRequestMessage() (WordOfWisdomRequestMessage, error) {
	var body WordOfWisdomRequestMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWordOfWisdomRequestMessage overwrites any union data inside the Message as the provided WordOfWisdomRequestMessage
func (t *Message) FromWordOfWisdomRequestMessage(v WordOfWisdomRequestMessage) error {
	t.MessageType = "WordOfWisdomRequestMessage"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWordOfWisdomRequestMessage performs a merge with any union data inside the Message, using the provided WordOfWisdomRequestMessage
func (t *Message) MergeWordOfWisdomRequestMessage(v WordOfWisdomRequestMessage) error {
	t.MessageType = "WordOfWisdomRequestMessage"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsWordOfWisdomResponseMessage returns the union data inside the Message as a WordOfWisdomResponseMessage
func (t Message) AsWordOfWisdomResponseMessage() (WordOfWisdomResponseMessage, error) {
	var body WordOfWisdomResponseMessage
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWordOfWisdomResponseMessage overwrites any union data inside the Message as the provided WordOfWisdomResponseMessage
func (t *Message) FromWordOfWisdomResponseMessage(v WordOfWisdomResponseMessage) error {
	t.MessageType = "WordOfWisdomResponseMessage"

	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWordOfWisdomResponseMessage performs a merge with any union data inside the Message, using the provided WordOfWisdomResponseMessage
func (t *Message) MergeWordOfWisdomResponseMessage(v WordOfWisdomResponseMessage) error {
	t.MessageType = "WordOfWisdomResponseMessage"

	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t Message) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"messageType"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Message) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "ChallengeRequestMessage":
		return t.AsChallengeRequestMessage()
	case "ChallengeResponseMessage":
		return t.AsChallengeResponseMessage()
	case "WordOfWisdomRequestMessage":
		return t.AsWordOfWisdomRequestMessage()
	case "WordOfWisdomResponseMessage":
		return t.AsWordOfWisdomResponseMessage()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Message) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["messageType"], err = json.Marshal(t.MessageType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'messageType': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *Message) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["messageType"]; found {
		err = json.Unmarshal(raw, &t.MessageType)
		if err != nil {
			return fmt.Errorf("error reading 'messageType': %w", err)
		}
	}

	return err
}
